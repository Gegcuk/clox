// Purpose of Each Function
// 	1.	initChunk: Prepares a new Chunk structure for use. It sets initial values for fields and initializes the constants array. 
//  It is typically called before any operations on a Chunk to ensure all fields are correctly initialized.
// 	2.	freeChunk: Releases all memory allocated for a Chunk and resets its fields to prevent dangling pointers. It ensures that 
//  resources are properly cleaned up, preventing memory leaks in applications using dynamic memory.
// 	3.	writeChunk: Dynamically appends an instruction and its associated line number to the Chunk. It grows the chunk’s storage 
//  capacity as needed, allowing for efficient storage of a sequence of bytecode instructions.
// 	4.	addConstant: Stores a constant value in the Chunk’s constants array and returns its index for future reference. This 
//  supports the storage and reuse of constant values in the generated bytecode, optimizing memory and runtime performance.

#include <stdlib.h>

// Include necessary headers for custom memory management, value handling, and chunk structure.
#include "chunk.h"
#include "memory.h"
#include "value.h"

// Initializes a new `Chunk` structure by resetting its fields and initializing its constants.
// This function is used to prepare a `Chunk` object for use by allocating resources and setting initial values.
void initChunk(Chunk* chunk) {
    chunk->count = 0;                  // Initialize the count of instructions to zero.
    chunk->capacity = 0;               // Start with zero capacity, which will grow as needed.
    chunk->code = NULL;                // Set the pointer to the instruction array to NULL (unallocated).
    chunk->lines = NULL;               // Set the pointer to the line number array to NULL (unallocated).
    initValueArray(&chunk->constants); // Initialize the array of constants, which stores constant values used in the chunk.
}

// Frees the memory used by a `Chunk` structure, including its code, lines, and constants.
// After freeing resources, the chunk is reset to an initialized state to avoid dangling pointers.
// This function is essential to avoid memory leaks in a dynamic memory allocation scenario.
void freeChunk(Chunk* chunk) {
    FREE_ARRAY(uint8_t, chunk->code, chunk->capacity); // Free the memory allocated for the instruction array.
    FREE_ARRAY(int, chunk->lines, chunk->capacity);    // Free the memory allocated for the line number array.
    freeValueArray(&chunk->constants);                 // Free the memory used by the constants array.
    initChunk(chunk);                                  // Reinitialize the chunk to a clean state.
}

// Appends a byte of code and its corresponding line number to a `Chunk`.
// Dynamically grows the storage capacity if necessary, ensuring the chunk can accommodate more instructions.
// This function is used to add new instructions to the chunk during bytecode generation.
void writeChunk(Chunk* chunk, uint8_t byte, int line) {
    if (chunk->capacity < chunk->count + 1) {  // Check if the current capacity is insufficient.
        int oldCapacity = chunk->capacity;    // Store the old capacity for resizing calculations.
        chunk->capacity = GROW_CAPACITY(oldCapacity); // Increase the capacity using a growth formula.
        chunk->code = GROW_ARRAY(uint8_t, chunk->code, oldCapacity, chunk->capacity); // Resize the instruction array.
        chunk->lines = GROW_ARRAY(int, chunk->lines, oldCapacity, chunk->capacity);   // Resize the line number array.
    }

    chunk->code[chunk->count] = byte; // Add the byte (instruction) to the instruction array.
    chunk->lines[chunk->count] = line; // Add the corresponding line number to the line number array.
    chunk->count++;                    // Increment the count of instructions.
}

// Adds a constant value to the `Chunk`'s constants array and returns its index.
// This function is essential for storing and reusing constant values during bytecode execution.
int addConstant(Chunk* chunk, Value value) {
    writeValueArray(&chunk->constants, value); // Add the value to the constants array.
    return chunk->constants.count - 1;        // Return the index of the newly added constant.
}